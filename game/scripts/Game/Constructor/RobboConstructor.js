// Generated by CoffeeScript 1.7.1
(function() {
  var app, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.app = (_ref = window.app) != null ? _ref : {};

  app = window.app;

  app.RobboConstructor = (function() {
    function RobboConstructor(universe, gameDesigner) {
      this.gameDesigner = gameDesigner;
      this.radomMazeStep = __bind(this.radomMazeStep, this);
      app.AssetLoader.constructorMode = true;
      this.assets = app.AssetLoader;
      this.canvas = $('#constructionyard');
      this.cursorCanvas = $('#currentcell');
      this.toolCanvas = $('#currenttool');
      this.cursorCtx = this.cursorCanvas.get(0).getContext('2d');
      this.toolCtx = this.toolCanvas.get(0).getContext('2d');
      this.mainCtx = this.canvas.get(0).getContext('2d');
      this.cursorCanvas.mousemove((function(_this) {
        return function(e) {
          return _this.onMouseMoveInCanvas(e);
        };
      })(this));
      this.setupDocumentEvents();
      this.setupClick();
      this.$map = $('.map');
      this.eventCtx = new app.EventAggregator();
      this.toolbar = new app.ConstructorToolbar(this.eventCtx);
      this.eventCtx.subscribe('selected-planet-changed', (function(_this) {
        return function(p) {
          return _this.changeMap(p);
        };
      })(this));
      this.eventCtx.subscribe('current-tool-changed', (function(_this) {
        return function() {
          return _this.drawToolIcon();
        };
      })(this));
      this.eventCtx.subscribe('map-height-changed', (function(_this) {
        return function(h) {
          return _this.updateMapHeight(h);
        };
      })(this));
      this.eventCtx.subscribe('map-width-changed', (function(_this) {
        return function(w) {
          return _this.updateMapWidth(w);
        };
      })(this));
      this.eventCtx.subscribe('colors-changed', (function(_this) {
        return function() {
          return _this.redrawMap();
        };
      })(this));
      this.eventCtx.subscribe('background-changed', (function(_this) {
        return function(color) {
          return _this.backgroundChanged(color);
        };
      })(this));
      this.eventCtx.subscribe('clear-planet', (function(_this) {
        return function() {
          return _this.clearPlanet();
        };
      })(this));
      this.eventCtx.subscribe('random-maze-next-step', (function(_this) {
        return function() {
          return _this.radomMazeStep();
        };
      })(this));
      this.games = app.Universe.games;
      this.gamesOptions = new app.GamesOptions(this.gameDesigner, this.games, this.eventCtx);
      this.setupMinimap();
    }

    RobboConstructor.prototype.clearPlanet = function() {
      var map, x, y, _i, _j, _ref1, _ref2;
      map = "";
      for (y = _i = 0, _ref1 = this.mapHeight - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; y = 0 <= _ref1 ? ++_i : --_i) {
        for (x = _j = 0, _ref2 = this.mapWidth - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; x = 0 <= _ref2 ? ++_j : --_j) {
          this.updateMap(x, y, "_..");
        }
      }
      this.chambers = null;
      return this.redrawMap();
    };

    RobboConstructor.prototype.updateMapHeight = function(h) {
      if (h > this.mapHeight) {
        this.addLines(h - this.mapHeight);
      } else {
        this.removeLines(h);
      }
      this.mapHeight = h;
      this.setHeight(h);
      this.redrawMap();
      return this.eventCtx.publish('map-updated', this.map);
    };

    RobboConstructor.prototype.addLines = function(n) {
      var i, line, x, _i, _j, _ref1, _ref2;
      for (i = _i = 0, _ref1 = n - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        line = "\n";
        for (x = _j = 0, _ref2 = this.mapWidth - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; x = 0 <= _ref2 ? ++_j : --_j) {
          line += "_..";
        }
        this.map += line;
      }
      this.map = this.map.replace(/[ ]/g, '.');
      return this.$map.val(this.map);
    };

    RobboConstructor.prototype.removeLines = function(n) {
      var lines;
      lines = this.map.split('\n');
      lines = lines.splice(0, n);
      this.map = lines.join('\n');
      return this.$map.val(this.map);
    };

    RobboConstructor.prototype.updateMapWidth = function(w) {
      if (w > this.mapWidth) {
        this.addColumns(w - this.mapWidth);
      } else {
        this.removeColumns(w);
      }
      this.mapWidth = w;
      this.setWidth(w);
      this.redrawMap();
      return this.eventCtx.publish('map-updated', this.map);
    };

    RobboConstructor.prototype.addColumns = function(n) {
      var cols, i, lines, x, _i, _j, _ref1, _ref2;
      lines = this.map.split('\n');
      for (i = _i = 0, _ref1 = lines.length - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        cols = "";
        for (x = _j = 0, _ref2 = n - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; x = 0 <= _ref2 ? ++_j : --_j) {
          cols += "_..";
        }
        lines[i] = lines[i] + cols;
      }
      this.map = lines.join('\n');
      return this.$map.val(this.map);
    };

    RobboConstructor.prototype.removeColumns = function(w) {
      var i, lines, _i, _ref1;
      lines = this.map.split('\n');
      for (i = _i = 0, _ref1 = lines.length - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        lines[i] = lines[i].substring(0, w * 3);
      }
      this.map = lines.join('\n');
      return this.$map.val(this.map);
    };

    RobboConstructor.prototype.changeMap = function(planet) {
      this.mapWidth = planet.width;
      this.mapHeight = planet.height;
      this.map = planet.map;
      this.map = this.map.replace(/[ ]/g, '.');
      this.$map.val(this.map);
      this.$map.attr("cols", planet.width * 3);
      this.$map.attr("rows", planet.height);
      this.setWidth();
      this.setHeight();
      this.setupColors(planet.background, planet.transparent, planet.colors);
      return this.redrawMap();
    };

    RobboConstructor.prototype.setupColors = function(background, transparent, colors) {
      console.log(background);
      console.log(transparent);
      return console.log(colors);
    };

    RobboConstructor.prototype.redrawMap = function() {
      var line, lines, x, y, _i, _j, _ref1, _ref2;
      lines = this.map.split('\n');
      for (y = _i = 0, _ref1 = this.mapHeight - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; y = 0 <= _ref1 ? ++_i : --_i) {
        line = lines[y];
        line = line.replace(/[ ]/g, '.');
        for (x = _j = 0, _ref2 = this.mapWidth - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; x = 0 <= _ref2 ? ++_j : --_j) {
          this.draw(x, y, line.substring(x * 3, x * 3 + 3));
        }
      }
    };

    RobboConstructor.prototype.onMouseMoveInCanvas = function(e) {
      this.x = Math.floor((e.pageX - this.cursorCanvas.offset().left) / 32.0);
      this.y = Math.floor((e.pageY - this.cursorCanvas.offset().top) / 32.0);
      this.cursorCtx.lineWidth = 1;
      this.cursorCtx.strokeStyle = 'white';
      this.cursorCtx.clearRect(0, 0, this.cursorCanvas.width(), this.cursorCanvas.height());
      this.cursorCtx.strokeRect(this.x * 32, this.y * 32, 32, 32);
      this.drawToolIcon();
      if (this.isLeftDown) {
        this.drawCurrentToolOnCanvas(this.x, this.y);
      }
      if (this.isRightDown) {
        return this.removeTail(this.x, this.y);
      }
    };

    RobboConstructor.prototype.drawToolIcon = function() {
      var asset;
      this.toolCtx.clearRect(0, 0, this.toolCanvas.width(), this.toolCanvas.height());
      if (this.toolbar.selectedTool == null) {
        return;
      }
      this.toolCtx.clearRect(0, 0, this.toolCanvas.width(), this.toolCanvas.height());
      asset = this.assets.getAsset(this.toolbar.selectedToolIcon);
      return this.toolCtx.putImageData(asset, this.x * 32, this.y * 32);
    };

    RobboConstructor.prototype.drawCurrentToolOnCanvas = function(x, y) {
      var asset;
      if (this.toolbar.selectedTool == null) {
        return;
      }
      asset = this.assets.getAsset(this.toolbar.selectedToolIcon);
      this.mainCtx.putImageData(asset, x * 32, y * 32);
      return this.updateMap(x, y, this.toolbar.selectedMapSign);
    };

    RobboConstructor.prototype.draw = function(x, y, sign) {
      var asset, assetName, e, tool;
      this.mainCtx.clearRect(x * 32, y * 32, 32, 32);
      if (sign[0] === "_") {
        return;
      }
      this.mainCtx.clearRect(x * 32, y * 32, 32, 32);
      tool = $('[data-map="' + sign + '"]');
      try {
        assetName = tool.data('tool-icon');
        asset = app.AssetLoader.getAsset(assetName);
        return this.mainCtx.putImageData(asset, x * 32, y * 32);
      } catch (_error) {
        e = _error;
        console.log("Coudn't load asst for '" + sign + "'. Found asset name " + assetName + ". [" + x + "," + y + "]");
        return console.log(e);
      }
    };

    RobboConstructor.prototype.setWidth = function(val) {
      this.canvas.attr('width', this.mapWidth * 32);
      this.toolCanvas.attr('width', this.mapWidth * 32);
      this.cursorCanvas.attr('width', this.mapWidth * 32);
      this.$map.attr("cols", this.mapWidth * 3);
      return this.$map.attr("rows", this.mapHeight);
    };

    RobboConstructor.prototype.setHeight = function(val) {
      this.canvas.attr('height', this.mapHeight * 32);
      this.toolCanvas.attr('height', this.mapHeight * 32);
      return this.cursorCanvas.attr('height', this.mapHeight * 32);
    };

    RobboConstructor.prototype.updateMap = function(x, y, sign) {
      var begin, e, end, line, lines;
      try {
        lines = this.map.split("\n");
        line = lines[y];
        begin = line.substring(0, x * 3);
        end = line.substring((x + 1) * 3);
        line = begin + sign + end;
        lines[y] = line;
        this.map = lines.join("\n");
        this.$map.val(this.map);
        return this.eventCtx.publish('map-updated', this.map);
      } catch (_error) {
        e = _error;
        return console.log(x + " " + y + " " + e);
      }
    };

    RobboConstructor.prototype.setupDocumentEvents = function() {
      this.isLeftDown = false;
      this.isRightDown = false;
      $('body').attr('onContextMenu', 'return false');
      $(document).mousedown((function(_this) {
        return function(e) {
          if (event.which === 1) {
            _this.isLeftDown = true;
          }
          if (event.which === 3) {
            return _this.isRightDown = true;
          }
        };
      })(this));
      return $(document).mouseup((function(_this) {
        return function(e) {
          if (event.which === 1) {
            _this.isLeftDown = false;
          }
          if (event.which === 3) {
            return _this.isRightDown = false;
          }
        };
      })(this));
    };

    RobboConstructor.prototype.setupClick = function() {
      this.cursorCanvas.mousedown((function(_this) {
        return function(e) {
          if (event.which === 1) {
            return _this.drawCurrentToolOnCanvas(_this.x, _this.y);
          } else if (event.which === 3) {
            if (_this.toolbar.selectedTool != null) {
              return _this.deselectTool();
            } else {
              return _this.removeTail(_this.y, _this.x);
            }
          }
        };
      })(this));
      return this.cursorCanvas.mouseout(function(e) {
        var leftDown, rightDown;
        leftDown = false;
        return rightDown = false;
      });
    };

    RobboConstructor.prototype.removeTail = function(x, y) {
      this.updateMap(x, y, "_..");
      this.mainCtx.clearRect(x * 32, y * 32, 32, 32);
    };

    RobboConstructor.prototype.backgroundChanged = function(color) {
      return this.canvas.css('background-color', color.toRgbaString());
    };

    RobboConstructor.prototype.deselectTool = function() {
      this.eventCtx.publish('tool-deselected');
      return this.drawToolIcon();
    };

    RobboConstructor.prototype.setupMinimap = function() {
      var callback;
      callback = (function(_this) {
        return function() {
          var minimap, minimap2D, scale;
          scale = 0.5;
          minimap = $('.minimap').attr('width', _this.canvas.width() * scale).attr('height', _this.canvas.height() * scale).css('background-color', _this.canvas.css('background-color'));
          minimap2D = minimap.get(0).getContext('2d');
          minimap2D.scale(scale, scale);
          minimap2D.drawImage(_this.canvas[0], 0, 0);
          return setTimeout((function() {
            return callback();
          }), 200);
        };
      })(this);
      return callback();
    };

    RobboConstructor.prototype.radomMazeStep = function() {
      if (this.chambers == null) {
        this.chambers = [];
        this.chambers.push(this.newChamber(0, this.mapWidth - 1, 0, this.mapHeight - 1));
      }
      if (this.chambers.length > 0) {
        this.splitLastChamber();
        return this.radomMazeStep();
      } else {

      }
    };

    RobboConstructor.prototype.newChamber = function(xs, xe, ys, ye) {
      return {
        x: {
          start: xs,
          end: xe
        },
        y: {
          start: ys,
          end: ye
        }
      };
    };

    RobboConstructor.prototype.minChamberDim = 4;

    RobboConstructor.prototype.minChamberArea = 70;

    RobboConstructor.prototype.splitLastChamber = function() {
      var c1, c2, chamber, door, minChamberSize, split, wall, x, y, _i, _j, _ref1, _ref2, _ref3, _ref4;
      chamber = this.chambers.pop();
      split = this.randomSplit(chamber);
      minChamberSize = 7;
      if ((chamber.y.end - chamber.y.start) > (chamber.x.end - chamber.x.start)) {
        if (chamber.y.end - chamber.y.start < minChamberSize) {
          return;
        }
        wall = split.y;
        door = split.ydoor;
        c1 = this.newChamber(chamber.x.start, chamber.x.end, chamber.y.start, wall);
        c2 = this.newChamber(chamber.x.start, chamber.x.end, wall, chamber.y.end);
        for (x = _i = _ref1 = chamber.x.start, _ref2 = chamber.x.end; _ref1 <= _ref2 ? _i <= _ref2 : _i >= _ref2; x = _ref1 <= _ref2 ? ++_i : --_i) {
          if (x !== door) {
            this.draw(x, wall, "w1.");
          }
        }
      } else {
        if (chamber.x.end - chamber.x.start < minChamberSize) {
          return;
        }
        wall = split.x;
        door = split.xdoor;
        c1 = this.newChamber(chamber.x.start, wall, chamber.y.start, chamber.y.end);
        c2 = this.newChamber(wall, chamber.x.end, chamber.y.start, chamber.y.end);
        for (y = _j = _ref3 = chamber.y.start, _ref4 = chamber.y.end; _ref3 <= _ref4 ? _j <= _ref4 : _j >= _ref4; y = _ref3 <= _ref4 ? ++_j : --_j) {
          if (y !== door) {
            this.draw(wall, y, "w1.");
          }
        }
      }
      if ((c1.x.end - c1.x.start) * (c1.y.end - c1.y.start) > this.minChamberArea) {
        this.chambers.push(c1);
      }
      if ((c2.x.end - c2.x.start) * (c2.y.end - c2.y.start) > this.minChamberArea) {
        return this.chambers.push(c2);
      }
    };

    RobboConstructor.prototype.randomSplit = function(chamber) {
      var res, xmax, xmin, ymax, ymin;
      console.log('chamber to be split: ' + JSON.stringify(chamber));
      xmin = chamber.x.start;
      xmax = chamber.x.end;
      ymin = chamber.y.start;
      ymax = chamber.y.end;
      res = {
        x: this.rand(xmin + this.minChamberDim + 1, xmax - this.minChamberDim - 1),
        y: this.rand(ymin + this.minChamberDim + 1, ymax - this.minChamberDim - 1),
        xdoor: this.rand(ymin + this.minChamberDim + 1, ymax - this.minChamberDim - 1),
        ydoor: this.rand(xmin + this.minChamberDim + 1, xmax - this.minChamberDim - 1)
      };
      return res;
    };

    RobboConstructor.prototype.rand = function(min, max) {
      return Math.floor(Math.random() * (max - min + 1) + min);
    };

    return RobboConstructor;

  })();

}).call(this);
